# 블록킹-논블록킹 vs 동기-비동기

- [상세 학습 자료](https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx)

- 핵심: 논블록킹이 전제되어야 비동기 처리가 가능해짐.
- 기본적으로 서로 별개의 개념이지만 혼용되는 경우가 많음.

## Blocking vs Non-blocking

- 블록킹 vs 논블록킹 : `제어권의 유무`. 제어의 관점. 현재 작업 중인 주체가 다른 다른 주체의 제어권(실행 여부 등)을 지니고 있다면 블록킹.

- Blocking : 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면
  `다른 주체의 작업이 끝날 때까지 기다렸다가` 자신의 작업을 재개하는 것

  - ex) '블록킹 상태가 되어 쓰레드 전체가 대기하게 된다'

```
  [작업 A]        [작업 A]
          [작업 B]
```

- Non-blocking : `다른 주체의 작업에 관련없이` 자신의 작업을 하는 것
  다른 작업이 시작되어도 자신이 하던 작업을 멈추지 않음.

```
  [작업 A 계속 처리되는 중]
         [작업 B]
```

## Synchronous vs Asynchronous

- 핵심: `보낸 요청에 대한 응답을 이후 작업을 위해 필요로 하는지의 여부`. 때문에 동기 처리는 응답을 받을 때까지 나머지 작업들 끝까지 수행 불가. 비동기 처리는 끝까지 수행해도 논리적으로는 무관하지만 논블록킹이어야 실제로 가능.

  - `동기 처리의 경우 블록킹이든 논블록킹이든 동일한 결과`. 논블록킹이어도 강제로 대기해야 함.

- Synchronous(동기) : 요청과 그 결과가 `동시에` 일어난다는 약속

  - 시간이 얼마가 걸리든지 `요청한 자리에 결과를 반환받음`
  - 다른 쓰레드에서 실행된 작업이 `어떤 결과값을 반환하는지`에 대해 메인 쓰레드가 관심을 지님.
  - 다른 작업이 끝난 순간 즉시 처리결과를 받아 활용.
  - 즉, 복수의 작업들이 순차적으로 하나씩 실행하는 구조 (slow)

- Asynchronous(비동기) : 요청과 결과가 `동시에 일어나지 않아도 된다`는 약속

  - 요청한 자리에 결과가 반환되지 않아도 됨. 때문에 다른 쓰레드의 작업이 처리되는 동안 메인 쓰레드는 대기하지 않고 다른 작업 수행 가능.
  - 복수의 작업이 같은 시간대에 각각 별도로 실행될 수 있다면 비동기
  - 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업 수행 가능. 효율적인 구조.

---

### Synchronous Blocking

- `작업의 다음 단계로 넘어가기 위해 다른 쓰레드에서의 처리 결과를 필요로 함. 때문에 하던 일 중단하고 가만히 있어야 함. 근데 애초에 다른 일 동시에 할 역량이 없음.`

  - 블록킹이므로 제어권이 완전히 넘어감. 즉 다른 작업이 수행되는 동안 메인 메인 쓰레드는 작업 중단하고 일방적으로 대기.
  - 다른 작업의 수행결과가 반환된 순간에 곧바로 처리하기 시작함.

- ex) Python에서 input으로 사용자의 입력을 받는 경우 사용자에게 제어권이 넘어감.
  1. 사용자의 입력을 기다리는 동안 파이썬 코드는 아무런 작업도 수행하지 않음.
  2. 값 입력시, 사용자로부터 제어권과 입력 결과를 함께 받아서 즉시 나머지 코드 실행.

### Synchronous Non-Blocking

- `다른 쓰레드에서의 처리 결과를 필요로 함. 근데 동시에 다른 일도 수행할 수는 있는 구조.`

- 논블록킹이므로 다른 작업을 실행시켰어도 자신의 제어권을 그대로 지니므로 다른 작업 수행 가능.
- 다만, 다른 작업의 실행 결과를 필요로 하는 동기 처리이므로 메인 쓰레드는 작업을 끝까지 다 수행 못하고 대기하는 상태. 다른 작업의 처리가 종료되었을 때 해당 결과를 활용하여 작업 처리.

- ex) 게임에서 맵을 넘어가는 동안 로딩 바의 퍼센트 계산.
  1. 다음 맵의 정보를 요청하고 응답이 올 때까지 메인 쓰레드는 요청 작업 처리 현황을 수치화하는 작업의 반복문 수행
  2. 다음 맵의 정보를 완전히 응답받으면, 메인 쓰레드는 반복문 탈출하고 다음 단계의 작업들 끝까지 다 수행

### Asynchronous Blocking : 비동기 처리를 못하는 기괴한 구조

- `다른 쓰레드에서의 처리 결과는 아무 때나 응답 받아도 됨. 그런데 다른 일 동시에 할 역량이 없어서 가만히 대기해야 하는 기괴한 구조.`

  - 비동기이므로 다른 작업의 처리 결과를 필요로 하지 않음.
  - 그렇지만 블록킹이므로 제어권이 넘어감. 다른 작업이 수행되는 동안 메인 메인 쓰레드는 작업 불가능.
  - 비동기 처리를 구현하려다가 실패한 케이스

### Asynchronous Non-Blocking

- `다른 쓰레드에서의 처리 결과는 아무 때나 응답 받아도 되는 구조, 그 사이에 하던 일은 끝까지 수행`

  - 자신의 제어권을 넘겨주지 않음.
  - 즉, 다른 쓰레드에서 작업이 수행되는지의 여부와 무관하게 메인 쓰레드에서는 다른 작업들 수행 가능.
  - 다른 쓰레드의 작업이 끝나고 처리 결과를 받으면, 메인 쓰레드는 기존에 하던 작업들을 전부 그대로 수행하고, 다른 작업의 처리결과를 활용한 작업을 수행.

- 다른 쓰레드의 처리 결과를 즉시 필요로 하지 않으므로(Async), 다른 쓰레드와 무관하게 자신의 작업을 처리하는 구조(Non-blocking)

- ex) JS에서 fetch/axios로 API 요청을 하고, 다른 작업을 하다가 콜백을 통해 추가적인 작업을 처리할 때 사용.
